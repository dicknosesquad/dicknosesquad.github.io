<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced HTML5 Game Engine</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: #000;
        }
        
        .game-container {
            position: relative;
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 24px;
        }

        .debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="loadingScreen" class="loading-screen">Loading...</div>
        <div id="debugOverlay" class="debug-overlay"></div>
    </div>

    <script>
        // Physics Engine
        class PhysicsEngine {
            constructor() {
                this.gravity = 980; // pixels per second squared
                this.friction = 0.8;
                this.restitution = 0.6;
            }

            applyForce(object, force, dt) {
                object.velocityX += (force.x * dt);
                object.velocityY += (force.y * dt);
            }

            applyGravity(object, dt) {
                object.velocityY += this.gravity * dt;
            }

            resolveCollision(obj1, obj2) {
                const nx = obj2.x - obj1.x;
                const ny = obj2.y - obj1.y;
                const dist = Math.sqrt(nx * nx + ny * ny);
                
                if (dist === 0) return;

                const normalX = nx / dist;
                const normalY = ny / dist;
                
                const relativeVelocityX = obj1.velocityX - obj2.velocityX;
                const relativeVelocityY = obj1.velocityY - obj2.velocityY;
                
                const impulse = -(1 + this.restitution) * (relativeVelocityX * normalX + relativeVelocityY * normalY) / 2;
                
                obj1.velocityX -= impulse * normalX;
                obj1.velocityY -= impulse * normalY;
                obj2.velocityX += impulse * normalX;
                obj2.velocityY += impulse * normalY;
                
                // Apply friction
                obj1.velocityX *= this.friction;
                obj1.velocityY *= this.friction;
                obj2.velocityX *= this.friction;
                obj2.velocityY *= this.friction;
            }
        }

        // Sound Engine
        class SoundEngine {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.sounds = new Map();
                this.masterVolume = this.context.createGain();
                this.masterVolume.connect(this.context.destination);
                this.masterVolume.gain.value = 0.5;
            }

            async loadSound(key, url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
                    this.sounds.set(key, audioBuffer);
                } catch (error) {
                    console.error('Error loading sound:', error);
                }
            }

            play(key, options = {}) {
                const sound = this.sounds.get(key);
                if (!sound) return;

                const source = this.context.createBufferSource();
                source.buffer = sound;

                const gainNode = this.context.createGain();
                gainNode.gain.value = options.volume || 1;

                source.connect(gainNode);
                gainNode.connect(this.masterVolume);

                if (options.loop) {
                    source.loop = true;
                }

                source.start(0);
                return source;
            }

            setMasterVolume(value) {
                this.masterVolume.gain.value = Math.max(0, Math.min(1, value));
            }
        }

        // Enhanced GameObject with Physics
        class GameObject {
            constructor(x, y, width, height, sprite = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.sprite = sprite;
                this.velocityX = 0;
                this.velocityY = 0;
                this.rotation = 0;
                this.mass = 1;
                this.collisionType = 'dynamic'; // 'dynamic', 'static', 'trigger'
                this.collisionLayer = 1;
                this.collisionMask = 1;
                this.boundingBox = {
                    type: 'rect', // 'rect' or 'circle'
                    radius: Math.max(width, height) / 2
                };
            }

            update(dt) {
                this.x += this.velocityX * dt;
                this.y += this.velocityY * dt;
            }

            collidesWith(other) {
                if (this.boundingBox.type === 'circle' && other.boundingBox.type === 'circle') {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < (this.boundingBox.radius + other.boundingBox.radius);
                } else {
                    // Rectangle collision
                    return (
                        this.x < other.x + other.width &&
                        this.x + this.width > other.x &&
                        this.y < other.y + other.height &&
                        this.y + this.height > other.y
                    );
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation);
                
                if (this.sprite) {
                    ctx.drawImage(
                        this.sprite,
                        -this.width / 2,
                        -this.height / 2,
                        this.width,
                        this.height
                    );
                }

                ctx.restore();
            }
        }

        // Collision System
        class CollisionSystem {
            constructor() {
                this.quadTree = null;
                this.collisionPairs = [];
            }

            update(objects) {
                this.collisionPairs = [];
                
                // Simple N^2 collision check (can be optimized with spatial partitioning)
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        const obj1 = objects[i];
                        const obj2 = objects[j];

                        // Check collision layers
                        if (!(obj1.collisionLayer & obj2.collisionMask) ||
                            !(obj2.collisionLayer & obj1.collisionMask)) {
                            continue;
                        }

                        if (obj1.collidesWith(obj2)) {
                            this.collisionPairs.push([obj1, obj2]);
                        }
                    }
                }

                return this.collisionPairs;
            }
        }

        // Enhanced Game Engine
        class GameEngine {
            constructor(canvasId, width = 800, height = 600) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = width;
                this.height = height;
                this.canvas.width = width;
                this.canvas.height = height;
                
                this.scenes = {};
                this.currentScene = null;
                this.resources = {
                    images: {},
                    sounds: {}
                };
                
                this.lastTime = 0;
                this.isRunning = false;
                this.debug = false;

                // Initialize systems
                this.physics = new PhysicsEngine();
                this.sound = new SoundEngine();
                this.collision = new CollisionSystem();

                // Initialize input handling
                this.keys = {};
                this.mouse = { x: 0, y: 0, pressed: false };
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (this.currentScene && this.currentScene.onKeyDown) {
                        this.currentScene.onKeyDown(e.code);
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    if (this.currentScene && this.currentScene.onKeyUp) {
                        this.currentScene.onKeyUp(e.code);
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                this.canvas.addEventListener('mousedown', () => {
                    this.mouse.pressed = true;
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.pressed = false;
                });
            }

            async loadResources(resourceMap) {
                const loadImage = (url) => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = url;
                    });
                };

                // Load images
                for (const [key, url] of Object.entries(resourceMap.images || {})) {
                    this.resources.images[key] = await loadImage(url);
                }

                // Load sounds
                for (const [key, url] of Object.entries(resourceMap.sounds || {})) {
                    await this.sound.loadSound(key, url);
                }

                document.getElementById('loadingScreen').style.display = 'none';
            }

            addScene(name, scene) {
                this.scenes[name] = scene;
                if (!this.currentScene) {
                    this.currentScene = scene;
                }
            }

            changeScene(sceneName) {
                if (this.scenes[sceneName]) {
                    if (this.currentScene) {
                        this.currentScene.onExit();
                    }
                    this.currentScene = this.scenes[sceneName];
                    this.currentScene.onEnter();
                }
            }

            toggleDebug() {
                this.debug = !this.debug;
            }

            updateDebugInfo() {
                if (!this.debug) {
                    document.getElementById('debugOverlay').innerHTML = '';
                    return;
                }

                const info = {
                    FPS: Math.round(1000 / (performance.now() - this.lastTime)),
                    Objects: this.currentScene ? this.currentScene.objects.length : 0,
                    'Mouse Position': `(${Math.round(this.mouse.x)}, ${Math.round(this.mouse.y)})`,
                };

                document.getElementById('debugOverlay').innerHTML = Object.entries(info)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join('<br>');
            }

            start() {
                this.isRunning = true;
                requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
            }

            gameLoop(timestamp) {
                if (!this.isRunning) return;

                const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1); // Cap at 100ms
                this.lastTime = timestamp;

                this.update(dt);
                this.draw();
                this.updateDebugInfo();

                requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
            }

            update(dt) {
                if (!this.currentScene) return;

                // Update all objects
                this.currentScene.objects.forEach(obj => {
                    if (obj.collisionType === 'dynamic') {
                        this.physics.applyGravity(obj, dt);
                    }
                    obj.update(dt);
                });

                // Check collisions
                const collisions = this.collision.update(this.currentScene.objects);
                
                // Resolve collisions
                collisions.forEach(([obj1, obj2]) => {
                    if (obj1.collisionType === 'dynamic' && obj2.collisionType === 'dynamic') {
                        this.physics.resolveCollision(obj1, obj2);
                    }
                });

                // Update scene
                this.currentScene.update(dt);
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Draw scene
                if (this.currentScene) {
                    this.currentScene.draw(this.ctx);
                }

                // Draw debug information
                if (this.debug) {
                    this.drawDebug();
                }
            }

            drawDebug() {
                if (!this.currentScene) return;

                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                this.ctx.lineWidth = 1;

                this.currentScene.objects.forEach(obj => {
                    this.ctx.beginPath();
                    if (obj.boundingBox.type === 'circle') {
                        this.ctx.arc(
                            obj.x + obj.width / 2,
                            obj.y + obj.height / 2,
                            obj.boundingBox.radius,
                            0,
                            Math.PI * 2
                        );
                    } else {
                        this.ctx.rect(obj.x, obj.y, obj.width, obj.height);
                    }
                    this.ctx.stroke();
                });
            }
        }

        // Enhanced Scene Class
        class Scene {
            constructor(game) {
                this.game = game;
                this.objects = [];
            }

            addObject(obj) {
                this.objects.push(obj);
                return obj;
            }

            removeObject(obj) {
                const index = this.objects.indexOf(obj);
                if (index !== -1) {
                    this.objects.splice(index, 1);
                }
            }

            update(dt) {
                // Override in specific scenes
